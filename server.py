from flask import Flask, render_template, request, jsonify
from flask_socketio import SocketIO, emit, join_room, leave_room
from game import Game, Card, Suit, Rank

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
socketio = SocketIO(app, cors_allowed_origins="*")

@app.route('/')
def index():
    return render_template('index.html')

# --- Storage ---
games = {}          # room_id -> Game instance
lobbies = {}        # room_id -> List of player names
users = {}          # user_id -> {'room': room_id, 'name': name} (PERSISTENT)
socket_map = {}     # sid -> user_id (EPHEMERAL - changes on refresh)

# --- Helper: Serialization ---
def serialize_card(card):
    if not card: return None
    return {'rank': card.rank.value, 'suit': card.suit.value, 'display': str(card)}

def get_game_state_for_player(game_instance, player_name):
    """
    Constructs a JSON-safe game state.
    CRITICAL: Hides opponents' hands to prevent cheating.
    """
    state = {
        'trump_suit': game_instance.trump_suit.value,
        'trump_card': serialize_card(game_instance.deck.trump_card),
        'deck_count': len(game_instance.deck.cards),
        'discard_pile_count': len(game_instance.discard_pile),
        'table_attack': [serialize_card(c) for c in game_instance.table_attack],
        'table_defense': [serialize_card(c) for c in game_instance.table_defense],
        'attacker_name': game_instance.players[game_instance.attacker_idx].name,
        'defender_name': game_instance.players[game_instance.defender_idx].name,
        'active_attacker_name': game_instance.players[game_instance.active_attacker_idx].name,
        'players': []
    }

    for p in game_instance.players:
        p_data = {
            'name': p.name,
            'is_me': (p.name == player_name),
            'card_count': len(p.hand),
            'hand': [] 
        }
        if p.name == player_name:
            p_data['hand'] = [serialize_card(c) for c in p.hand]
        state['players'].append(p_data)
        
    return state

def broadcast_game_state(room_id):
    """Sends the specific game state to EACH player individually."""
    if room_id not in games: return

    game = games[room_id]
    
    # Iterate through all active sockets
    for sid, user_id in socket_map.items():
        user = users.get(user_id)
        if user and user['room'] == room_id:
            state = get_game_state_for_player(game, user['name'])
            socketio.emit('game_update', state, room=sid)

def get_user_from_sid(sid):
    """Helper to look up user data from socket ID"""
    user_id = socket_map.get(sid)
    if not user_id: return None
    return users.get(user_id)

# --- SocketIO Events ---

@socketio.on('connect')
def on_connect():
    print(f"Client connected: {request.sid}")

@socketio.on('disconnect')
def on_disconnect():
    user_id = socket_map.get(request.sid)
    if user_id:
        print(f"User disconnected: {users[user_id]['name']} (ID: {user_id})")
        # Remove the socket mapping, but KEEP the user session so they can reconnect
        del socket_map[request.sid]

@socketio.on('join_game')
def on_join(data):
    """
    Data: {'room': 'room1', 'name': 'Alice', 'userId': 'uuid-from-client'}
    """
    room = data['room']
    name = data['name']
    user_id = data['userId'] # Unique ID generated by Client
    
    join_room(room)
    
    # 1. Register/Update User Session
    users[user_id] = {'room': room, 'name': name}
    socket_map[request.sid] = user_id # Map new socket to existing user
    
    print(f"User {name} joined/reconnected to {room}")

    # 2. Check for RECONNECT (Game already running)
    if room in games:
        game = games[room]
        # Check if this player is actually in the game
        if any(p.name == name for p in game.players):
            print(f"-> Reconnection detected for {name}")
            # Send them the game state immediately
            state = get_game_state_for_player(game, name)
            emit('game_update', state)
            return
        else:
             emit('error', {'message': "Game already started, and you are not in it!"})
             return

    # 3. Normal Join (Lobby)
    if room not in lobbies:
        lobbies[room] = []
    
    if name not in lobbies[room]:
        lobbies[room].append(name)
        
    emit('lobby_update', {'players': lobbies[room]}, room=room)

@socketio.on('start_game')
def on_start(data):
    user = get_user_from_sid(request.sid)
    if not user: return
    
    room = user['room']
    if room in games: return 
        
    player_names = lobbies.get(room, [])
    if len(player_names) < 2:
        emit('error', {'message': "Need at least 2 players to start!"})
        return

    try:
        new_game = Game(player_names) 
        games[room] = new_game
        broadcast_game_state(room)
    except ValueError as e:
        emit('error', {'message': str(e)})

# --- Game Actions (Updated to use get_user_from_sid) ---

@socketio.on('attack')
def on_attack(data):
    user = get_user_from_sid(request.sid)
    if not user: return
    game = games.get(user['room'])
    if not game: return
    
    try:
        rank = Rank(data['rank'])
        suit = Suit(data['suit'])
        card = Card(rank, suit)
        player = next(p for p in game.players if p.name == user['name'])
        
        game.attack(card, player)
        broadcast_game_state(user['room'])
    except Exception as e:
        emit('error', {'message': str(e)})

@socketio.on('defend')
def on_defend(data):
    user = get_user_from_sid(request.sid)
    if not user: return
    game = games.get(user['room'])
    if not game: return

    try:
        att_card = Card(Rank(data['attack_rank']), Suit(data['attack_suit']))
        def_card = Card(Rank(data['defend_rank']), Suit(data['defend_suit']))
        player = next(p for p in game.players if p.name == user['name'])
        
        game.defend(att_card, def_card, player)
        broadcast_game_state(user['room'])
    except Exception as e:
        emit('error', {'message': str(e)})

@socketio.on('pass')
def on_pass_turn(data):
    user = get_user_from_sid(request.sid)
    if not user: return
    game = games.get(user['room'])
    if not game: return
    
    try:
        pass_card = Card(Rank(data['rank']), Suit(data['suit']))
        player = next(p for p in game.players if p.name == user['name'])
        
        game.pass_attack(pass_card, player)
        broadcast_game_state(user['room'])
    except Exception as e:
        emit('error', {'message': str(e)})

@socketio.on('skip')
def on_skip_turn(data):
    user = get_user_from_sid(request.sid)
    if not user: return
    game = games.get(user['room'])
    if not game: return
    
    try:
        player = next(p for p in game.players if p.name == user['name'])
        game.skip_attack_turn(player)
        
        loser_msg = game.check_loser()
        if loser_msg:
             emit('game_over', {'message': loser_msg}, room=user['room'])
        
        broadcast_game_state(user['room'])
    except Exception as e:
        emit('error', {'message': str(e)})

@socketio.on('take')
def on_take(data):
    user = get_user_from_sid(request.sid)
    if not user: return
    game = games.get(user['room'])
    if not game: return
    
    try:
        player = next(p for p in game.players if p.name == user['name'])
        game.action_take(player)
        
        loser_msg = game.check_loser()
        if loser_msg:
             emit('game_over', {'message': loser_msg}, room=user['room'])
             
        broadcast_game_state(user['room'])
    except Exception as e:
        emit('error', {'message': str(e)})

if __name__ == '__main__':
    socketio.run(app, debug=True)